use std::fs::{File, OpenOptions};
use std::io::prelude::*;
use std::io::{BufReader, BufWriter};
use std::path::PathBuf;
use std::process::exit;
use std::time::Duration;

use anyhow::{anyhow, Context, Error, Result};
use jsonwebtoken::EncodingKey;
use log::{debug, error, info, warn};
use serde::{Deserialize, Serialize};
use structopt::StructOpt;
use url::Host;
use url::Url;

#[derive(Debug)]
struct EnvironmentConfig {
    /// The full address to run the server on
    server_addr: Option<Url>,
    /// Database URL (will distinguish between postgres, sqlite, sled)
    database_addr: Option<Url>,
    /// Path to PEM encoded ES256 key for creating auth tokens
    authkey_path: Option<PathBuf>,
    /// Duration in seconds that an auth token is valid for
    session_expiration: Option<u64>,
    /// Server config file location
    config_path: Option<PathBuf>,
}

#[derive(Debug, StructOpt)]
struct CliConfig {
    /// The full address to run the server on
    server_addr: Option<Url>,
    /// Database URL (will distinguish between postgres, sqlite, sled)
    database_addr: Option<Url>,
    /// Path to PEM encoded ES256 key for creating auth tokens
    authkey_path: Option<PathBuf>,
    /// Duration in seconds that an auth token is valid for
    session_expiration: Option<u64>,
    /// Server config file location
    config_path: Option<PathBuf>,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct YamlConfig {
    /// The full address to run the server on
    server_addr: Option<Url>,
    /// Database URL (will distinguish between postgres, sqlite, sled)
    database_addr: Option<Url>,
    /// Path to PEM encoded ES256 key for creating auth tokens
    authkey_path: Option<PathBuf>,
    /// Duration in seconds that an auth token is valid for
    session_expiration: Option<u64>,
}

/// Combined server config generated by layering all 3 config methods
/// Follows a simple priority system of env -> cli args -> config file when initialized
/// Will fail to initialize if the 3 config methods combined miss a required option
#[derive(Debug, Deserialize, Serialize)]
struct LayeredServerConfig {
    /// The full address to run the server on
    server_addr: Url,
    /// Database URL (will distinguish between postgres, sqlite, sled)
    database_addr: Url,
    /// PEM encoded ES256 key for creating auth tokens
    authkey_path: PathBuf,
    /// Duration in seconds that an auth token is valid for
    /// Optional
    session_expiration: Duration,
}

#[derive(Debug)]
/// Unable Config struct that contains all relevant config information in accessible fields/types
/// Made from a LayeredServerConfig.
pub struct ServerConfig {
    /// The full address to run the server on
    pub server_addr: Url,
    /// Database URL (will distinguish between postgres, sqlite, sled)
    pub database_addr: Url,
    /// PEM encoded ES256 key for creating auth tokens
    pub authkey: EncodingKey,
    /// Duration in seconds that an auth token is valid for
    /// Optional
    pub session_expiration: Duration,
}

impl EnvironmentConfig {
    fn new() -> Self {
        let server_addr = match std::env::var("MAELSTROM_SERVER_ADDRESS") {
            Ok(v) => match Url::parse(&v) {
                Ok(v) => Some(v),
                Err(e) => {
                    error!("Unable to parse server_addr to url. Reason is {:?}", e);
                    exit(1)
                },
            },
            Err(_) => None,
        };
        let database_addr = match std::env::var("MAELSTROM_DATABASE_ADDRESS") {
            Ok(v) => match Url::parse(&v) {
                Ok(v) => Some(v),
                Err(e) => {
                    error!("Unable to parse database_addr to url. Reason is {:?}", e);
                    exit(1)
                },
            },
            Err(_) => None,
        };
        let authkey_path = match std::env::var("MAELSTROM_AUTHKEY_PATH") {
            Ok(v) => Some(PathBuf::from(&v)),
            Err(_) => None,
        };
        let session_expiration = match std::env::var("MAELSTROM_SESSION_EXPIRATION") {
            Ok(v) => match v.parse() {
                Ok(v) => Some(v),
                Err(e) => {
                    error!("Unable to parse session_expiration to u64. Reason is {:?}", e);
                    exit(1)
                },
            },
            Err(_) => None,
        };
        let config_path = match std::env::var("MAELSTROM_CONF_PATH") {
            Ok(v) => Some(PathBuf::from(&v)),
            Err(_) => None,
        };

        Self {
            server_addr,
            database_addr,
            authkey_path,
            session_expiration,
            config_path,
        }
    }
}

impl YamlConfig {
    fn default() -> Self {
        let yaml = Self {
            server_addr: Some(Url::parse("https://example.net").unwrap()),
            database_addr: Some(Url::parse("postgres://db.example.net").unwrap()),
            authkey_path: Some(PathBuf::from("/etc/maelstrom/authkey.pem")),
            session_expiration: Some(3000),
        };
        yaml
    }

    fn load() -> Self {
        unimplemented!()
    }

    fn save(&self, path: &PathBuf) -> Result<(), Error> {
        let s = serde_yaml::to_string(self).with_context(|| {
            format!("Failed to serilize to yaml. Provided struct is {:?}", self)
        })?;
        info!("Saved yaml config file");
        debug!("Saved yaml looks like: {:?}", s);
        match OpenOptions::new().write(true).create(true).open(&path) {
            Ok(mut v) => {
                v.write_all(s.as_bytes())?;
                Ok(())
            }
            Err(e) => Err(anyhow!(
                "Unable to open file for writing. Reason is {:?}",
                e
            )),
        }
    }
}

impl LayeredServerConfig {
    fn new() -> Self {
        let env = EnvironmentConfig::new();
        let cli = CliConfig::from_args();
        let yaml_path = match env.config_path {
            Some(v) => v,
            None => match cli.config_path {
                Some(v) => v,
                None => {
                    error!("No config path specified. This argument is required!");
                    exit(1) // TODO: Determine proper "standardized" exit code for missing arguments
                }
            },
        };
        let yaml = match File::open(&yaml_path) {
            Ok(v) => {
                let rdr = BufReader::new(v);
                match serde_yaml::from_reader(rdr) {
                    Ok(v) => v,
                    Err(e) => {
                        error!("Unable to read yaml file. Reason is {:?}", e);
                        exit(1)
                    }
                }
            }
            Err(e) => match e.kind() {
                std::io::ErrorKind::NotFound => {
                    let yaml = YamlConfig::default();
                    warn!("No yaml file found. Creating default yaml file and writing to disk. If this is a first run, exit and edit before continuing");
                    debug!("Default yaml looks like: {:?}", yaml);
                    match yaml.save(&yaml_path) {
                        Ok(()) => yaml,
                        Err(e) => {
                            error!("Unable to write default yaml file. This is required! Error is {:?}", e);
                            exit(1)
                        }
                    }
                }
                _ => {
                    error!("Unable to handle error {:?}", e);
                    exit(1)
                }
            },
        };
        Self {
            server_addr: match env.server_addr {
                Some(v) => v,
                None => match cli.server_addr {
                    Some(v) => v,
                    None => match yaml.server_addr {
                        Some(v) => v,
                        None => {
                            error!("Option server_addr is required!");
                            exit(1)
                        }
                    },
                },
            },
            database_addr: match env.database_addr {
                Some(v) => v,
                None => match cli.database_addr {
                    Some(v) => v,
                    None => match yaml.database_addr {
                        Some(v) => v,
                        None => {
                            error!("Option database_addr is required!");
                            exit(1)
                        }
                    },
                },
            },
            authkey_path: match env.authkey_path {
                Some(v) => v,
                None => match cli.authkey_path {
                    Some(v) => v,
                    None => match yaml.authkey_path {
                        Some(v) => v,
                        None => {
                            error!("Option authkey_path is required!");
                            exit(1)
                        }
                    },
                },
            },
            session_expiration: match env.session_expiration {
                Some(v) => Duration::from_secs(v),
                None => match cli.session_expiration {
                    Some(v) => Duration::from_secs(v),
                    None => match yaml.session_expiration {
                        Some(v) => Duration::from_secs(v),
                        None => Duration::from_secs(60),
                    },
                },
            },
        }
    }
}

impl ServerConfig {
    fn new() -> Self {
        let layered_config = LayeredServerConfig::new();
        Self {
            server_addr: layered_config.server_addr,
            database_addr: layered_config.database_addr,
            authkey: match File::open(layered_config.authkey_path) {
                Ok(mut v) => {
                    let mut key = match &v.metadata() {
                        Ok(v) => Vec::<u8>::with_capacity(v.len() as usize),
                        Err(e) => unimplemented!(),
                    };
                    match v.read_to_end(&mut key) {
                        Ok(_) => match EncodingKey::from_ec_pem(&key) {
                            Ok(v) => v,
                            Err(e) => {
                                error!("Unable to parse supplied key. Reason is {:?}", e);
                                exit(1)
                            }
                        },
                        Err(e) => {
                            error!("Unable to read key file. Reason is {:?}", e);
                            exit(1)
                        }
                    }
                }
                Err(e) => {
                    error!("Unable to open authkey file. Reason is {:?}", e);
                    exit(1)
                }
            },
            session_expiration: layered_config.session_expiration,
        }
    }
}
